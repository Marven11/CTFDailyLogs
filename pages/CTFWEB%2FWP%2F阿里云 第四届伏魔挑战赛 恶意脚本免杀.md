# 介绍
	- 今年的伏魔挑战赛和上一年一样，包含webshell免杀和恶意脚本免杀两个赛道。上一年因为身体原因只打了一天，今年也很不幸因为期末考试和[[毕业设计]]只打了一天，写了两个python的反弹shell脚本。
	- 上一年的查杀引擎是很好绕过的，尤其是恶意脚本查杀引擎，用一下python的语法特性就能绕过，一次就是100的奖金，今年很明显比上一年难了很多，当然奖金也变成了400一个
- # 查杀引擎
	- 伏魔挑战赛是免杀绕过挑战赛，简单来说选手需要编写webshell或反弹shell脚本并绕过查杀引擎的检测，每个webshell是几百上千的奖金，每个恶意脚本几百块。
	- 查杀引擎不仅有常规的静态分析，还有行为检测和深度学习等新技术，相对于简单的ctf比赛和d盾之类的玩意还是强很多的
	- 首先常规的动态函数调用，字符串混淆之类的套路大概率是没用的。这些套路不仅特征明显还没法防范行为检测。
	- 为了绕过静态分析，在上一年的比赛中我用了python的列表推导式还有sys.modules这python特性实现了免杀。今年查杀引擎加强了很多，这两个套路当然是没用了的。
- # 纯函数与副作用 - 为什么base64没用
	- 我对编程语言理论了解不深，也没有学过相关的课程，但是为了解释绕过静态分析的手段还是必须解释这两个概念。
	- 实际上像字符串拼接、[PHPFuck](https://splitline.github.io/PHPFuck/)这样的手法是没法从根本上绕过静态分析的。这些手法即使很多人喜欢用（包括很多比我强得多的大佬），也可以真的绕过一些写得不好的查杀引擎，那也是在根本上存在缺陷的。
	- 比如说下面这段代码
		- ```php
		  $a = implode("",['p','h','p','i','n','f','o','(',')']);
		  ```
	- 虽然没有任何关键字，好像查杀引擎根本查不出来什么东西，但是查杀引擎只要解析执行这个表达式就能知道implode计算出了什么字符串了，然后跟踪这个字符串就可以实现查杀。
	- 像字符串拼接、字符串替换、base64编码、array_map之类的手法全部都存在这样的缺陷。查杀引擎只要解析执行一下就能轻松查杀。
	- 为什么？因为这些函数**除了计算结果之外什么都不做！他们是纯函数！**
	- 如果一个表达式没有副作用，那查杀引擎只要解析执行一下就能计算出这个表达式的值！然后就可以通过值的内容进行查杀！
	- 为了从根本上绕过静态分析，我们只能编写更加复杂，更加“不纯”的函数，让查杀引擎不能直接解析执行，分析表达式的内容。
- # 绕过静态分析
	- 今年我使用了污染全局变量、字符串格式化等等方法来做免杀，成功绕过了两次
	- 污染全局变量
		- 因为python的globals()返回一个字典，我们可以通过写入这个字典实现为变量赋值
		- 所以我们可以通过写入这个字典的方式来赋值变量，隐藏控制流
		- 当然单纯的把变量赋值改成修改字典是没用的，还需要配合其他技巧实现绕过
	- 字符串格式化
		- python的字符串格式化支持的功能还是很复杂的，我们可以在字符串格式化中取对象的属性。比如``"{0.aaa}"``就是取第一个变量的`aaa`属性，格式化的时候这样传入对象就行：``"{0.aaa}".format(o)``
		- ```python
		  class Data:
		      aaa = 114
		  
		  s = "{0.aaa}".format(Data())
		  ```
	- 隐藏控制流
		- 刚刚我们说了可以在python上实现一个类似汇编的语言实现隐藏控制流的效果。实际我们不需要实现一个功能完整的编程语言。
		- 汇编大致上是“动作+操作数”的形式，我们只需要仿照汇编，将每一步需要做的动作和对应的操作数写在一个列表中，然后用for循环一条一条执行就行了
		- 比如说我们可以把下面的python代码
			- ```python
			  s = skt
			  s = s.socket
			  ```
		- 改成这种形式。也就是把对应的变量名、属性名和动作写在列表中
			- ```python
			  [
			    ["set_var", "s", "skt"],
			    ["getattr", "s", "socket"],
			  ]
			  ```
		- 然后用for循环遍历上面的列表，执行对应的动作，就可以实现隐藏控制流了
- # 绕过行为分析
	- 今年的查杀引擎应该是加上了行为分析的功能，可以分析脚本执行时的系统调用。
	- 反弹shell脚本执行的时候肯定是需要调用系统功能，从而创建socket、加载`/bin/sh`的
	- 可是如果创建socket、连接服务器、调用exec家族函数加载`/bin/sh`的这一套流程被检测出来的话那就没了
	- 为了绕过行为分析，我们可以使用API hammering的技巧绕过检测。
	- API hammering也就是在实际的操作之间插入大量无用系统调用，不断地读写临时文件，列出文件夹，创建socket，创建子进程，从而让查杀引擎无法分析脚本功能。
	- 这一步用简单的python代码就能实现
		- ```python
		  def hammer():
		      file = None
		      n = random.randint(3000, 5000)
		      for _ in range(n):
		          p = random.random()
		          if p < 0.5:
		              import socket
		              socket.socket(2, 1)
		          elif p < 0.98:
		              import tempfile
		              if file and Path(file).exists():
		                  Path(file).unlink()
		              file = tempfile.mktemp()
		          else:
		              import os
		              p = os.fork()
		              if p == 0:
		                  exit()
		  ```
	-